#include <iostream>
#include <array>
#include <vector>
using std::cin;
using std::cout;
using std::endl;

template<typename T> void vector_info(const std::vector<T>& vec);

//#define STL_ARRAY
#define STIL_VECTOR
#define tab "\t"
#define delimeter "\n------------------------------\n"

void main()
{
	setlocale(LC_ALL, "");
#ifdef STL_ARRAY
	const int n = 5;
	std::array<int, n> arr;
	for (int i = 0; i < arr.size(); i++)
	{
		arr.at(i) = rand() % 100;
	}
	try
	{
		for (int i = 0; i < arr.size(); i++)
		{
			cout << arr.at(i) << tab;
		}
	}
	catch (const std::exception& e)
	{
		std::cerr << e.what() << endl;
	}
	catch (...)
	{
		std::cout << "Error: Something went wrong" << endl;
	}
	cout << endl;
	for (int i :arr)
	{
		cout << i << tab;
	}
	cout << endl;
#endif

#ifdef STIL_VECTOR
	std::vector<int> vec = { 0,1,1,2,3,5,8,13,21,34 };
	for (int i = 0; i < vec.size(); i++)
	{
		cout << vec[i] << tab;
	}
	cout << endl;
	vector_info(vec);
	vec.push_back(55);
	for (std::vector<int>::iterator it = vec.begin(); it != vec.end(); ++it)
		cout << *it << tab;
	cout << endl;
	for (std::vector<int>::reverse_iterator it = vec.rbegin(); it != vec.rend(); ++it)
		cout << *it << tab;
	cout << endl;
	vector_info(vec);
	//vec.shrink_to_fit(); урезает capacity до фактического размера
	//vec.reserve(16);
	//vec.push_back(1024);
	vec.resize(8);
	for (int i : vec)cout << i << tab; cout << endl;
	vector_info(vec);
	cout << vec.front() << endl;
	cout << vec.back() << endl;
	///////////////////////////////
	int index;
	int value;
	do
	{
		cout << "Введите индекс добавляемого элемента: "; cin >> index;
		cout << "Введите значение добавляемого элемента: "; cin >> value;
	} while (index > vec.capacity());
	vec.insert(vec.begin() + index, value);
	for (int i : vec)cout << i << tab; cout << endl;
#endif // STIL_VECTOR

}

template<typename T> void vector_info(const std::vector<T>& vec)
{
	cout << "Size: " << vec.size() << endl;
	cout << "MaxSize: " << vec.max_size() << endl;
	cout << "Capacity: " << vec.capacity() << endl; //Объем зарезервированной памяти. Зарезервированная память нужна для того, чтобы ускорить процесс добавления элементов и избежать необходимости переопределять память при каждом добавлении элемента.
	cout << delimeter << endl;
}
	/*
	Каждый контейнер объявлен в отдельном заголовочном файле. Для использования любого контейнера нужно подключить соответствующий одноименный заголовок.
	
	Абсолютно все сущности в STL являются шаблонными (могут работать с любыми типами данных). В особенности это касается контейнеров. Для каждого контейнера обязательно явно указывать тип данных,
	который будет хранится в этом контейнере.

	Array - это контейнер, который хранит данные в виде статического массива.

	Если контейнер для хранения данных использует массив, то в нем обязательно будут перегружены квадратные скобки.
	Если в контейнере есть квадратные скобки, то в нем так же обязательно будет метод "at", который так же возвращает значение по индексу.

	Метод "at" при выходе за пределы контейнера бросает исключение "out_of_range exception", чего не делают квадратные скобки.

	Исключения:

	Исключительная ситуаиця - это ошибка на этапе выполнения, которая приводит к аварийному завершению программы с потерей данных. Такие ошибки могут быть вызваны неверными действиями программиста или пользователя.
	Неверные действия программиста могут быть исправлены изменением исходного кода программы.
	На неверные действия пользователя повлиять никак нельзя. Мы можем лишь обработать эту исключительную ситуацию.

	Для того, чтобы обработать исключение его нужно поймать(catch), а для его поимки нужен бросок (throw). 
	Исключение может бросить процессор(аппаратное исключение), операционная система(системное исключение) или программа(прикладное исключение).

	Языки C и C++ позволяют обрабатывать только прикладные исключения, которые явно бросает какая-то функция, написанная на этих языках.

	Для обработки исключений, код, который потенциально может сгенерировать исключение, помещается в блок try. Блок try - это поле, на которое прилетают исключения.
	У блока try должен быть хотя бы один обработчик (блок catch). Обработчик исключения - это функция с одним параметром, которая неявно вызывается при возникноввении соответствующего исключения.

	У одного блока try не может быть двух однотипных обработчиков, но может быть один универсальный.

	Обработка исключения позволяет восстановить работу без аварийного завершения.
	*/
	/*
	Vector

	Это контейнер, который хранит данные, в виде динамического массива
	*/